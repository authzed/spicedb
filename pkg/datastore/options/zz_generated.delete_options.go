// Code generated by github.com/ecordell/optgen. DO NOT EDIT.
package options

import defaults "github.com/creasty/defaults"

type DeleteOptionsOption func(d *DeleteOptions)

// NewDeleteOptionsWithOptions creates a new DeleteOptions with the passed in options set
func NewDeleteOptionsWithOptions(opts ...DeleteOptionsOption) *DeleteOptions {
	d := &DeleteOptions{}
	for _, o := range opts {
		o(d)
	}
	return d
}

// NewDeleteOptionsWithOptionsAndDefaults creates a new DeleteOptions with the passed in options set starting from the defaults
func NewDeleteOptionsWithOptionsAndDefaults(opts ...DeleteOptionsOption) *DeleteOptions {
	d := &DeleteOptions{}
	defaults.MustSet(d)
	for _, o := range opts {
		o(d)
	}
	return d
}

// ToOption returns a new DeleteOptionsOption that sets the values from the passed in DeleteOptions
func (d *DeleteOptions) ToOption() DeleteOptionsOption {
	return func(to *DeleteOptions) {
		to.DeleteLimit = d.DeleteLimit
	}
}

// DebugMap returns a map form of DeleteOptions for debugging
func (d *DeleteOptions) DebugMap() map[string]any {
	debugMap := map[string]any{}
	if d.DeleteLimit == nil {
		debugMap["DeleteLimit"] = "nil"
	} else {
		debugMap["DeleteLimit"] = *d.DeleteLimit
	}
	return debugMap
}

// FlatDebugMap returns a flattened map form of DeleteOptions for debugging
// Nested maps are flattened using dot notation (e.g., "parent.child.field")
func (d *DeleteOptions) FlatDebugMap() map[string]any {
	var flatten func(m map[string]any) map[string]any
	flatten = func(m map[string]any) map[string]any {
		result := make(map[string]any, len(m))
		for key, value := range m {
			childMap, ok := value.(map[string]any)
			if ok {
				for childKey, childValue := range flatten(childMap) {
					result[key+"."+childKey] = childValue
				}
				continue
			}
			result[key] = value
		}
		return result
	}
	return flatten(d.DebugMap())
}

// DeleteOptionsWithOptions configures an existing DeleteOptions with the passed in options set
func DeleteOptionsWithOptions(d *DeleteOptions, opts ...DeleteOptionsOption) *DeleteOptions {
	for _, o := range opts {
		o(d)
	}
	return d
}

// WithOptions configures the receiver DeleteOptions with the passed in options set
func (d *DeleteOptions) WithOptions(opts ...DeleteOptionsOption) *DeleteOptions {
	for _, o := range opts {
		o(d)
	}
	return d
}

// WithDeleteLimit returns an option that can set DeleteLimit on a DeleteOptions
func WithDeleteLimit(deleteLimit *uint64) DeleteOptionsOption {
	return func(d *DeleteOptions) {
		d.DeleteLimit = deleteLimit
	}
}
