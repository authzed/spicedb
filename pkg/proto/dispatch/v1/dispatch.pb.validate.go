// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: dispatch/v1/dispatch.proto

package dispatchv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DispatchCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchCheckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchCheckRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DispatchCheckRequestMultiError, or nil if none found.
func (m *DispatchCheckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchCheckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMetadata() == nil {
		err := DispatchCheckRequestValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchCheckRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchCheckRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchCheckRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResourceRelation() == nil {
		err := DispatchCheckRequestValidationError{
			field:  "ResourceRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResourceRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchCheckRequestValidationError{
					field:  "ResourceRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchCheckRequestValidationError{
					field:  "ResourceRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchCheckRequestValidationError{
				field:  "ResourceRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSubject() == nil {
		err := DispatchCheckRequestValidationError{
			field:  "Subject",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchCheckRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchCheckRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchCheckRequestValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ResultsSetting

	// no validation rules for Debug

	if len(errors) > 0 {
		return DispatchCheckRequestMultiError(errors)
	}

	return nil
}

// DispatchCheckRequestMultiError is an error wrapping multiple validation
// errors returned by DispatchCheckRequest.ValidateAll() if the designated
// constraints aren't met.
type DispatchCheckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchCheckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchCheckRequestMultiError) AllErrors() []error { return m }

// DispatchCheckRequestValidationError is the validation error returned by
// DispatchCheckRequest.Validate if the designated constraints aren't met.
type DispatchCheckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchCheckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchCheckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchCheckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchCheckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchCheckRequestValidationError) ErrorName() string {
	return "DispatchCheckRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchCheckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchCheckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchCheckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchCheckRequestValidationError{}

// Validate checks the field values on DispatchCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchCheckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchCheckResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DispatchCheckResponseMultiError, or nil if none found.
func (m *DispatchCheckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchCheckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchCheckResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchCheckResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchCheckResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetResultsByResourceId()))
		i := 0
		for key := range m.GetResultsByResourceId() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResultsByResourceId()[key]
			_ = val

			// no validation rules for ResultsByResourceId[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, DispatchCheckResponseValidationError{
							field:  fmt.Sprintf("ResultsByResourceId[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, DispatchCheckResponseValidationError{
							field:  fmt.Sprintf("ResultsByResourceId[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return DispatchCheckResponseValidationError{
						field:  fmt.Sprintf("ResultsByResourceId[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return DispatchCheckResponseMultiError(errors)
	}

	return nil
}

// DispatchCheckResponseMultiError is an error wrapping multiple validation
// errors returned by DispatchCheckResponse.ValidateAll() if the designated
// constraints aren't met.
type DispatchCheckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchCheckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchCheckResponseMultiError) AllErrors() []error { return m }

// DispatchCheckResponseValidationError is the validation error returned by
// DispatchCheckResponse.Validate if the designated constraints aren't met.
type DispatchCheckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchCheckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchCheckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchCheckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchCheckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchCheckResponseValidationError) ErrorName() string {
	return "DispatchCheckResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchCheckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchCheckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchCheckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchCheckResponseValidationError{}

// Validate checks the field values on ResourceCheckResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResourceCheckResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceCheckResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResourceCheckResultMultiError, or nil if none found.
func (m *ResourceCheckResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceCheckResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Membership

	if all {
		switch v := interface{}(m.GetExpression()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceCheckResultValidationError{
					field:  "Expression",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceCheckResultValidationError{
					field:  "Expression",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpression()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceCheckResultValidationError{
				field:  "Expression",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResourceCheckResultMultiError(errors)
	}

	return nil
}

// ResourceCheckResultMultiError is an error wrapping multiple validation
// errors returned by ResourceCheckResult.ValidateAll() if the designated
// constraints aren't met.
type ResourceCheckResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceCheckResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceCheckResultMultiError) AllErrors() []error { return m }

// ResourceCheckResultValidationError is the validation error returned by
// ResourceCheckResult.Validate if the designated constraints aren't met.
type ResourceCheckResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceCheckResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceCheckResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceCheckResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceCheckResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceCheckResultValidationError) ErrorName() string {
	return "ResourceCheckResultValidationError"
}

// Error satisfies the builtin error interface
func (e ResourceCheckResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceCheckResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceCheckResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceCheckResultValidationError{}

// Validate checks the field values on DispatchExpandRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchExpandRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchExpandRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DispatchExpandRequestMultiError, or nil if none found.
func (m *DispatchExpandRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchExpandRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMetadata() == nil {
		err := DispatchExpandRequestValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchExpandRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchExpandRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchExpandRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResourceAndRelation() == nil {
		err := DispatchExpandRequestValidationError{
			field:  "ResourceAndRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResourceAndRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchExpandRequestValidationError{
					field:  "ResourceAndRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchExpandRequestValidationError{
					field:  "ResourceAndRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceAndRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchExpandRequestValidationError{
				field:  "ResourceAndRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExpansionMode

	if len(errors) > 0 {
		return DispatchExpandRequestMultiError(errors)
	}

	return nil
}

// DispatchExpandRequestMultiError is an error wrapping multiple validation
// errors returned by DispatchExpandRequest.ValidateAll() if the designated
// constraints aren't met.
type DispatchExpandRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchExpandRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchExpandRequestMultiError) AllErrors() []error { return m }

// DispatchExpandRequestValidationError is the validation error returned by
// DispatchExpandRequest.Validate if the designated constraints aren't met.
type DispatchExpandRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchExpandRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchExpandRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchExpandRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchExpandRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchExpandRequestValidationError) ErrorName() string {
	return "DispatchExpandRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchExpandRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchExpandRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchExpandRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchExpandRequestValidationError{}

// Validate checks the field values on DispatchExpandResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchExpandResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchExpandResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DispatchExpandResponseMultiError, or nil if none found.
func (m *DispatchExpandResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchExpandResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchExpandResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchExpandResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchExpandResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTreeNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchExpandResponseValidationError{
					field:  "TreeNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchExpandResponseValidationError{
					field:  "TreeNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTreeNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchExpandResponseValidationError{
				field:  "TreeNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DispatchExpandResponseMultiError(errors)
	}

	return nil
}

// DispatchExpandResponseMultiError is an error wrapping multiple validation
// errors returned by DispatchExpandResponse.ValidateAll() if the designated
// constraints aren't met.
type DispatchExpandResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchExpandResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchExpandResponseMultiError) AllErrors() []error { return m }

// DispatchExpandResponseValidationError is the validation error returned by
// DispatchExpandResponse.Validate if the designated constraints aren't met.
type DispatchExpandResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchExpandResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchExpandResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchExpandResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchExpandResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchExpandResponseValidationError) ErrorName() string {
	return "DispatchExpandResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchExpandResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchExpandResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchExpandResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchExpandResponseValidationError{}

// Validate checks the field values on Cursor with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Cursor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Cursor with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CursorMultiError, or nil if none found.
func (m *Cursor) ValidateAll() error {
	return m.validate(true)
}

func (m *Cursor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DispatchVersion

	if len(errors) > 0 {
		return CursorMultiError(errors)
	}

	return nil
}

// CursorMultiError is an error wrapping multiple validation errors returned by
// Cursor.ValidateAll() if the designated constraints aren't met.
type CursorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CursorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CursorMultiError) AllErrors() []error { return m }

// CursorValidationError is the validation error returned by Cursor.Validate if
// the designated constraints aren't met.
type CursorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CursorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CursorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CursorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CursorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CursorValidationError) ErrorName() string { return "CursorValidationError" }

// Error satisfies the builtin error interface
func (e CursorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCursor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CursorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CursorValidationError{}

// Validate checks the field values on DispatchReachableResourcesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DispatchReachableResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchReachableResourcesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DispatchReachableResourcesRequestMultiError, or nil if none found.
func (m *DispatchReachableResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchReachableResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMetadata() == nil {
		err := DispatchReachableResourcesRequestValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResourceRelation() == nil {
		err := DispatchReachableResourcesRequestValidationError{
			field:  "ResourceRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResourceRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "ResourceRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "ResourceRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesRequestValidationError{
				field:  "ResourceRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSubjectRelation() == nil {
		err := DispatchReachableResourcesRequestValidationError{
			field:  "SubjectRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubjectRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "SubjectRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "SubjectRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubjectRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesRequestValidationError{
				field:  "SubjectRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OptionalLimit

	if len(errors) > 0 {
		return DispatchReachableResourcesRequestMultiError(errors)
	}

	return nil
}

// DispatchReachableResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by
// DispatchReachableResourcesRequest.ValidateAll() if the designated
// constraints aren't met.
type DispatchReachableResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchReachableResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchReachableResourcesRequestMultiError) AllErrors() []error { return m }

// DispatchReachableResourcesRequestValidationError is the validation error
// returned by DispatchReachableResourcesRequest.Validate if the designated
// constraints aren't met.
type DispatchReachableResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchReachableResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchReachableResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchReachableResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchReachableResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchReachableResourcesRequestValidationError) ErrorName() string {
	return "DispatchReachableResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchReachableResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchReachableResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchReachableResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchReachableResourcesRequestValidationError{}

// Validate checks the field values on ReachableResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReachableResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReachableResource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReachableResourceMultiError, or nil if none found.
func (m *ReachableResource) ValidateAll() error {
	return m.validate(true)
}

func (m *ReachableResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceId

	// no validation rules for ResultStatus

	if len(errors) > 0 {
		return ReachableResourceMultiError(errors)
	}

	return nil
}

// ReachableResourceMultiError is an error wrapping multiple validation errors
// returned by ReachableResource.ValidateAll() if the designated constraints
// aren't met.
type ReachableResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReachableResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReachableResourceMultiError) AllErrors() []error { return m }

// ReachableResourceValidationError is the validation error returned by
// ReachableResource.Validate if the designated constraints aren't met.
type ReachableResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReachableResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReachableResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReachableResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReachableResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReachableResourceValidationError) ErrorName() string {
	return "ReachableResourceValidationError"
}

// Error satisfies the builtin error interface
func (e ReachableResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReachableResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReachableResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReachableResourceValidationError{}

// Validate checks the field values on DispatchReachableResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DispatchReachableResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchReachableResourcesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DispatchReachableResourcesResponseMultiError, or nil if none found.
func (m *DispatchReachableResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchReachableResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesResponseValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesResponseValidationError{
					field:  "Resource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesResponseValidationError{
				field:  "Resource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfterResponseCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchReachableResourcesResponseValidationError{
					field:  "AfterResponseCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchReachableResourcesResponseValidationError{
					field:  "AfterResponseCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResponseCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchReachableResourcesResponseValidationError{
				field:  "AfterResponseCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DispatchReachableResourcesResponseMultiError(errors)
	}

	return nil
}

// DispatchReachableResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by
// DispatchReachableResourcesResponse.ValidateAll() if the designated
// constraints aren't met.
type DispatchReachableResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchReachableResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchReachableResourcesResponseMultiError) AllErrors() []error { return m }

// DispatchReachableResourcesResponseValidationError is the validation error
// returned by DispatchReachableResourcesResponse.Validate if the designated
// constraints aren't met.
type DispatchReachableResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchReachableResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchReachableResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchReachableResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchReachableResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchReachableResourcesResponseValidationError) ErrorName() string {
	return "DispatchReachableResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchReachableResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchReachableResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchReachableResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchReachableResourcesResponseValidationError{}

// Validate checks the field values on DispatchLookupResourcesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchLookupResourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchLookupResourcesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DispatchLookupResourcesRequestMultiError, or nil if none found.
func (m *DispatchLookupResourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchLookupResourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMetadata() == nil {
		err := DispatchLookupResourcesRequestValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetObjectRelation() == nil {
		err := DispatchLookupResourcesRequestValidationError{
			field:  "ObjectRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetObjectRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "ObjectRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "ObjectRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesRequestValidationError{
				field:  "ObjectRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSubject() == nil {
		err := DispatchLookupResourcesRequestValidationError{
			field:  "Subject",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "Subject",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesRequestValidationError{
				field:  "Subject",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "Context",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesRequestValidationError{
				field:  "Context",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OptionalLimit

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DispatchLookupResourcesRequestMultiError(errors)
	}

	return nil
}

// DispatchLookupResourcesRequestMultiError is an error wrapping multiple
// validation errors returned by DispatchLookupResourcesRequest.ValidateAll()
// if the designated constraints aren't met.
type DispatchLookupResourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchLookupResourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchLookupResourcesRequestMultiError) AllErrors() []error { return m }

// DispatchLookupResourcesRequestValidationError is the validation error
// returned by DispatchLookupResourcesRequest.Validate if the designated
// constraints aren't met.
type DispatchLookupResourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchLookupResourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchLookupResourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchLookupResourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchLookupResourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchLookupResourcesRequestValidationError) ErrorName() string {
	return "DispatchLookupResourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchLookupResourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchLookupResourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchLookupResourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchLookupResourcesRequestValidationError{}

// Validate checks the field values on ResolvedResource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResolvedResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolvedResource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResolvedResourceMultiError, or nil if none found.
func (m *ResolvedResource) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolvedResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceId

	// no validation rules for Permissionship

	if len(errors) > 0 {
		return ResolvedResourceMultiError(errors)
	}

	return nil
}

// ResolvedResourceMultiError is an error wrapping multiple validation errors
// returned by ResolvedResource.ValidateAll() if the designated constraints
// aren't met.
type ResolvedResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolvedResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolvedResourceMultiError) AllErrors() []error { return m }

// ResolvedResourceValidationError is the validation error returned by
// ResolvedResource.Validate if the designated constraints aren't met.
type ResolvedResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolvedResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolvedResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolvedResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolvedResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolvedResourceValidationError) ErrorName() string { return "ResolvedResourceValidationError" }

// Error satisfies the builtin error interface
func (e ResolvedResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolvedResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolvedResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolvedResourceValidationError{}

// Validate checks the field values on DispatchLookupResourcesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchLookupResourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchLookupResourcesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DispatchLookupResourcesResponseMultiError, or nil if none found.
func (m *DispatchLookupResourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchLookupResourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResolvedResource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesResponseValidationError{
					field:  "ResolvedResource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesResponseValidationError{
					field:  "ResolvedResource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolvedResource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesResponseValidationError{
				field:  "ResolvedResource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfterResponseCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupResourcesResponseValidationError{
					field:  "AfterResponseCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupResourcesResponseValidationError{
					field:  "AfterResponseCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResponseCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupResourcesResponseValidationError{
				field:  "AfterResponseCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DispatchLookupResourcesResponseMultiError(errors)
	}

	return nil
}

// DispatchLookupResourcesResponseMultiError is an error wrapping multiple
// validation errors returned by DispatchLookupResourcesResponse.ValidateAll()
// if the designated constraints aren't met.
type DispatchLookupResourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchLookupResourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchLookupResourcesResponseMultiError) AllErrors() []error { return m }

// DispatchLookupResourcesResponseValidationError is the validation error
// returned by DispatchLookupResourcesResponse.Validate if the designated
// constraints aren't met.
type DispatchLookupResourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchLookupResourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchLookupResourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchLookupResourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchLookupResourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchLookupResourcesResponseValidationError) ErrorName() string {
	return "DispatchLookupResourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchLookupResourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchLookupResourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchLookupResourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchLookupResourcesResponseValidationError{}

// Validate checks the field values on DispatchLookupSubjectsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchLookupSubjectsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchLookupSubjectsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DispatchLookupSubjectsRequestMultiError, or nil if none found.
func (m *DispatchLookupSubjectsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchLookupSubjectsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMetadata() == nil {
		err := DispatchLookupSubjectsRequestValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupSubjectsRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetResourceRelation() == nil {
		err := DispatchLookupSubjectsRequestValidationError{
			field:  "ResourceRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetResourceRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "ResourceRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "ResourceRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupSubjectsRequestValidationError{
				field:  "ResourceRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetSubjectRelation() == nil {
		err := DispatchLookupSubjectsRequestValidationError{
			field:  "SubjectRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubjectRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "SubjectRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "SubjectRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubjectRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupSubjectsRequestValidationError{
				field:  "SubjectRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OptionalLimit

	if all {
		switch v := interface{}(m.GetOptionalCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupSubjectsRequestValidationError{
					field:  "OptionalCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptionalCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupSubjectsRequestValidationError{
				field:  "OptionalCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DispatchLookupSubjectsRequestMultiError(errors)
	}

	return nil
}

// DispatchLookupSubjectsRequestMultiError is an error wrapping multiple
// validation errors returned by DispatchLookupSubjectsRequest.ValidateAll()
// if the designated constraints aren't met.
type DispatchLookupSubjectsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchLookupSubjectsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchLookupSubjectsRequestMultiError) AllErrors() []error { return m }

// DispatchLookupSubjectsRequestValidationError is the validation error
// returned by DispatchLookupSubjectsRequest.Validate if the designated
// constraints aren't met.
type DispatchLookupSubjectsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchLookupSubjectsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchLookupSubjectsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchLookupSubjectsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchLookupSubjectsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchLookupSubjectsRequestValidationError) ErrorName() string {
	return "DispatchLookupSubjectsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchLookupSubjectsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchLookupSubjectsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchLookupSubjectsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchLookupSubjectsRequestValidationError{}

// Validate checks the field values on FoundSubject with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FoundSubject) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FoundSubject with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FoundSubjectMultiError, or
// nil if none found.
func (m *FoundSubject) ValidateAll() error {
	return m.validate(true)
}

func (m *FoundSubject) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubjectId

	if all {
		switch v := interface{}(m.GetCaveatExpression()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FoundSubjectValidationError{
					field:  "CaveatExpression",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FoundSubjectValidationError{
					field:  "CaveatExpression",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCaveatExpression()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FoundSubjectValidationError{
				field:  "CaveatExpression",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetExcludedSubjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FoundSubjectValidationError{
						field:  fmt.Sprintf("ExcludedSubjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FoundSubjectValidationError{
						field:  fmt.Sprintf("ExcludedSubjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FoundSubjectValidationError{
					field:  fmt.Sprintf("ExcludedSubjects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FoundSubjectMultiError(errors)
	}

	return nil
}

// FoundSubjectMultiError is an error wrapping multiple validation errors
// returned by FoundSubject.ValidateAll() if the designated constraints aren't met.
type FoundSubjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FoundSubjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FoundSubjectMultiError) AllErrors() []error { return m }

// FoundSubjectValidationError is the validation error returned by
// FoundSubject.Validate if the designated constraints aren't met.
type FoundSubjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FoundSubjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FoundSubjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FoundSubjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FoundSubjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FoundSubjectValidationError) ErrorName() string { return "FoundSubjectValidationError" }

// Error satisfies the builtin error interface
func (e FoundSubjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFoundSubject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FoundSubjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FoundSubjectValidationError{}

// Validate checks the field values on FoundSubjects with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FoundSubjects) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FoundSubjects with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FoundSubjectsMultiError, or
// nil if none found.
func (m *FoundSubjects) ValidateAll() error {
	return m.validate(true)
}

func (m *FoundSubjects) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFoundSubjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FoundSubjectsValidationError{
						field:  fmt.Sprintf("FoundSubjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FoundSubjectsValidationError{
						field:  fmt.Sprintf("FoundSubjects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FoundSubjectsValidationError{
					field:  fmt.Sprintf("FoundSubjects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FoundSubjectsMultiError(errors)
	}

	return nil
}

// FoundSubjectsMultiError is an error wrapping multiple validation errors
// returned by FoundSubjects.ValidateAll() if the designated constraints
// aren't met.
type FoundSubjectsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FoundSubjectsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FoundSubjectsMultiError) AllErrors() []error { return m }

// FoundSubjectsValidationError is the validation error returned by
// FoundSubjects.Validate if the designated constraints aren't met.
type FoundSubjectsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FoundSubjectsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FoundSubjectsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FoundSubjectsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FoundSubjectsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FoundSubjectsValidationError) ErrorName() string { return "FoundSubjectsValidationError" }

// Error satisfies the builtin error interface
func (e FoundSubjectsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFoundSubjects.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FoundSubjectsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FoundSubjectsValidationError{}

// Validate checks the field values on DispatchLookupSubjectsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DispatchLookupSubjectsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DispatchLookupSubjectsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DispatchLookupSubjectsResponseMultiError, or nil if none found.
func (m *DispatchLookupSubjectsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DispatchLookupSubjectsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetFoundSubjectsByResourceId()))
		i := 0
		for key := range m.GetFoundSubjectsByResourceId() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFoundSubjectsByResourceId()[key]
			_ = val

			// no validation rules for FoundSubjectsByResourceId[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, DispatchLookupSubjectsResponseValidationError{
							field:  fmt.Sprintf("FoundSubjectsByResourceId[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, DispatchLookupSubjectsResponseValidationError{
							field:  fmt.Sprintf("FoundSubjectsByResourceId[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return DispatchLookupSubjectsResponseValidationError{
						field:  fmt.Sprintf("FoundSubjectsByResourceId[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupSubjectsResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupSubjectsResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupSubjectsResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAfterResponseCursor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DispatchLookupSubjectsResponseValidationError{
					field:  "AfterResponseCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DispatchLookupSubjectsResponseValidationError{
					field:  "AfterResponseCursor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAfterResponseCursor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DispatchLookupSubjectsResponseValidationError{
				field:  "AfterResponseCursor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DispatchLookupSubjectsResponseMultiError(errors)
	}

	return nil
}

// DispatchLookupSubjectsResponseMultiError is an error wrapping multiple
// validation errors returned by DispatchLookupSubjectsResponse.ValidateAll()
// if the designated constraints aren't met.
type DispatchLookupSubjectsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DispatchLookupSubjectsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DispatchLookupSubjectsResponseMultiError) AllErrors() []error { return m }

// DispatchLookupSubjectsResponseValidationError is the validation error
// returned by DispatchLookupSubjectsResponse.Validate if the designated
// constraints aren't met.
type DispatchLookupSubjectsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DispatchLookupSubjectsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DispatchLookupSubjectsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DispatchLookupSubjectsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DispatchLookupSubjectsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DispatchLookupSubjectsResponseValidationError) ErrorName() string {
	return "DispatchLookupSubjectsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DispatchLookupSubjectsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDispatchLookupSubjectsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DispatchLookupSubjectsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DispatchLookupSubjectsResponseValidationError{}

// Validate checks the field values on ResolverMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResolverMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResolverMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResolverMetaMultiError, or
// nil if none found.
func (m *ResolverMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ResolverMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetAtRevision()) > 1024 {
		err := ResolverMetaValidationError{
			field:  "AtRevision",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetDepthRemaining() <= 0 {
		err := ResolverMetaValidationError{
			field:  "DepthRemaining",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RequestId

	if len(m.GetTraversalBloom()) > 1024 {
		err := ResolverMetaValidationError{
			field:  "TraversalBloom",
			reason: "value length must be at most 1024 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ResolverMetaMultiError(errors)
	}

	return nil
}

// ResolverMetaMultiError is an error wrapping multiple validation errors
// returned by ResolverMeta.ValidateAll() if the designated constraints aren't met.
type ResolverMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResolverMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResolverMetaMultiError) AllErrors() []error { return m }

// ResolverMetaValidationError is the validation error returned by
// ResolverMeta.Validate if the designated constraints aren't met.
type ResolverMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResolverMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResolverMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResolverMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResolverMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResolverMetaValidationError) ErrorName() string { return "ResolverMetaValidationError" }

// Error satisfies the builtin error interface
func (e ResolverMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResolverMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResolverMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResolverMetaValidationError{}

// Validate checks the field values on ResponseMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResponseMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResponseMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResponseMetaMultiError, or
// nil if none found.
func (m *ResponseMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ResponseMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DispatchCount

	// no validation rules for DepthRequired

	// no validation rules for CachedDispatchCount

	if all {
		switch v := interface{}(m.GetDebugInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponseMetaValidationError{
					field:  "DebugInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponseMetaValidationError{
					field:  "DebugInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebugInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponseMetaValidationError{
				field:  "DebugInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResponseMetaMultiError(errors)
	}

	return nil
}

// ResponseMetaMultiError is an error wrapping multiple validation errors
// returned by ResponseMeta.ValidateAll() if the designated constraints aren't met.
type ResponseMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponseMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponseMetaMultiError) AllErrors() []error { return m }

// ResponseMetaValidationError is the validation error returned by
// ResponseMeta.Validate if the designated constraints aren't met.
type ResponseMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponseMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponseMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponseMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponseMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponseMetaValidationError) ErrorName() string { return "ResponseMetaValidationError" }

// Error satisfies the builtin error interface
func (e ResponseMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponseMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponseMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponseMetaValidationError{}

// Validate checks the field values on DebugInformation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DebugInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebugInformation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebugInformationMultiError, or nil if none found.
func (m *DebugInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *DebugInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCheck()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebugInformationValidationError{
					field:  "Check",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebugInformationValidationError{
					field:  "Check",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCheck()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebugInformationValidationError{
				field:  "Check",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebugInformationMultiError(errors)
	}

	return nil
}

// DebugInformationMultiError is an error wrapping multiple validation errors
// returned by DebugInformation.ValidateAll() if the designated constraints
// aren't met.
type DebugInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebugInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebugInformationMultiError) AllErrors() []error { return m }

// DebugInformationValidationError is the validation error returned by
// DebugInformation.Validate if the designated constraints aren't met.
type DebugInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebugInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebugInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebugInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebugInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebugInformationValidationError) ErrorName() string { return "DebugInformationValidationError" }

// Error satisfies the builtin error interface
func (e DebugInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebugInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebugInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebugInformationValidationError{}

// Validate checks the field values on CheckDebugTrace with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CheckDebugTrace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckDebugTrace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckDebugTraceMultiError, or nil if none found.
func (m *CheckDebugTrace) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckDebugTrace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckDebugTraceValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckDebugTraceValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckDebugTraceValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ResourceRelationType

	{
		sorted_keys := make([]string, len(m.GetResults()))
		i := 0
		for key := range m.GetResults() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetResults()[key]
			_ = val

			// no validation rules for Results[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, CheckDebugTraceValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, CheckDebugTraceValidationError{
							field:  fmt.Sprintf("Results[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return CheckDebugTraceValidationError{
						field:  fmt.Sprintf("Results[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for IsCachedResult

	for idx, item := range m.GetSubProblems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckDebugTraceValidationError{
						field:  fmt.Sprintf("SubProblems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckDebugTraceValidationError{
						field:  fmt.Sprintf("SubProblems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckDebugTraceValidationError{
					field:  fmt.Sprintf("SubProblems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDuration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckDebugTraceValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckDebugTraceValidationError{
					field:  "Duration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDuration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckDebugTraceValidationError{
				field:  "Duration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckDebugTraceMultiError(errors)
	}

	return nil
}

// CheckDebugTraceMultiError is an error wrapping multiple validation errors
// returned by CheckDebugTrace.ValidateAll() if the designated constraints
// aren't met.
type CheckDebugTraceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckDebugTraceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckDebugTraceMultiError) AllErrors() []error { return m }

// CheckDebugTraceValidationError is the validation error returned by
// CheckDebugTrace.Validate if the designated constraints aren't met.
type CheckDebugTraceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckDebugTraceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckDebugTraceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckDebugTraceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckDebugTraceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckDebugTraceValidationError) ErrorName() string { return "CheckDebugTraceValidationError" }

// Error satisfies the builtin error interface
func (e CheckDebugTraceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckDebugTrace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckDebugTraceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckDebugTraceValidationError{}
