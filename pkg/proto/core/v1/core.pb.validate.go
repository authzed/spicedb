// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: core/v1/core.proto

package corev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RelationTuple with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RelationTuple) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationTuple with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RelationTupleMultiError, or
// nil if none found.
func (m *RelationTuple) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationTuple) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetObjectAndRelation() == nil {
		err := RelationTupleValidationError{
			field:  "ObjectAndRelation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetObjectAndRelation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationTupleValidationError{
					field:  "ObjectAndRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationTupleValidationError{
					field:  "ObjectAndRelation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectAndRelation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationTupleValidationError{
				field:  "ObjectAndRelation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetUser() == nil {
		err := RelationTupleValidationError{
			field:  "User",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationTupleValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationTupleValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationTupleValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RelationTupleMultiError(errors)
	}

	return nil
}

// RelationTupleMultiError is an error wrapping multiple validation errors
// returned by RelationTuple.ValidateAll() if the designated constraints
// aren't met.
type RelationTupleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationTupleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationTupleMultiError) AllErrors() []error { return m }

// RelationTupleValidationError is the validation error returned by
// RelationTuple.Validate if the designated constraints aren't met.
type RelationTupleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationTupleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationTupleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationTupleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationTupleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationTupleValidationError) ErrorName() string { return "RelationTupleValidationError" }

// Error satisfies the builtin error interface
func (e RelationTupleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationTuple.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationTupleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationTupleValidationError{}

// Validate checks the field values on ObjectAndRelation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ObjectAndRelation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectAndRelation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectAndRelationMultiError, or nil if none found.
func (m *ObjectAndRelation) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectAndRelation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNamespace()) > 128 {
		err := ObjectAndRelationValidationError{
			field:  "Namespace",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ObjectAndRelation_Namespace_Pattern.MatchString(m.GetNamespace()) {
		err := ObjectAndRelationValidationError{
			field:  "Namespace",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetObjectId()) > 128 {
		err := ObjectAndRelationValidationError{
			field:  "ObjectId",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ObjectAndRelation_ObjectId_Pattern.MatchString(m.GetObjectId()) {
		err := ObjectAndRelationValidationError{
			field:  "ObjectId",
			reason: "value does not match regex pattern \"^(([a-zA-Z0-9_][a-zA-Z0-9/_|-]{0,127})|\\\\*)$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRelation()) > 64 {
		err := ObjectAndRelationValidationError{
			field:  "Relation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ObjectAndRelation_Relation_Pattern.MatchString(m.GetRelation()) {
		err := ObjectAndRelationValidationError{
			field:  "Relation",
			reason: "value does not match regex pattern \"^(\\\\.\\\\.\\\\.|[a-z][a-z0-9_]{1,62}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ObjectAndRelationMultiError(errors)
	}

	return nil
}

// ObjectAndRelationMultiError is an error wrapping multiple validation errors
// returned by ObjectAndRelation.ValidateAll() if the designated constraints
// aren't met.
type ObjectAndRelationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectAndRelationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectAndRelationMultiError) AllErrors() []error { return m }

// ObjectAndRelationValidationError is the validation error returned by
// ObjectAndRelation.Validate if the designated constraints aren't met.
type ObjectAndRelationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectAndRelationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectAndRelationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectAndRelationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectAndRelationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectAndRelationValidationError) ErrorName() string {
	return "ObjectAndRelationValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectAndRelationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectAndRelation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectAndRelationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectAndRelationValidationError{}

var _ObjectAndRelation_Namespace_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _ObjectAndRelation_ObjectId_Pattern = regexp.MustCompile("^(([a-zA-Z0-9_][a-zA-Z0-9/_|-]{0,127})|\\*)$")

var _ObjectAndRelation_Relation_Pattern = regexp.MustCompile("^(\\.\\.\\.|[a-z][a-z0-9_]{1,62}[a-z0-9])$")

// Validate checks the field values on RelationReference with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RelationReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationReferenceMultiError, or nil if none found.
func (m *RelationReference) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNamespace()) > 128 {
		err := RelationReferenceValidationError{
			field:  "Namespace",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RelationReference_Namespace_Pattern.MatchString(m.GetNamespace()) {
		err := RelationReferenceValidationError{
			field:  "Namespace",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRelation()) > 64 {
		err := RelationReferenceValidationError{
			field:  "Relation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_RelationReference_Relation_Pattern.MatchString(m.GetRelation()) {
		err := RelationReferenceValidationError{
			field:  "Relation",
			reason: "value does not match regex pattern \"^(\\\\.\\\\.\\\\.|[a-z][a-z0-9_]{1,62}[a-z0-9])$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RelationReferenceMultiError(errors)
	}

	return nil
}

// RelationReferenceMultiError is an error wrapping multiple validation errors
// returned by RelationReference.ValidateAll() if the designated constraints
// aren't met.
type RelationReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationReferenceMultiError) AllErrors() []error { return m }

// RelationReferenceValidationError is the validation error returned by
// RelationReference.Validate if the designated constraints aren't met.
type RelationReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationReferenceValidationError) ErrorName() string {
	return "RelationReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e RelationReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationReferenceValidationError{}

var _RelationReference_Namespace_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _RelationReference_Relation_Pattern = regexp.MustCompile("^(\\.\\.\\.|[a-z][a-z0-9_]{1,62}[a-z0-9])$")

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.UserOneof.(type) {

	case *User_Userset:

		if m.GetUserset() == nil {
			err := UserValidationError{
				field:  "Userset",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUserset()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "Userset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserValidationError{
						field:  "Userset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUserset()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserValidationError{
					field:  "Userset",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := UserValidationError{
			field:  "UserOneof",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on Zookie with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Zookie) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Zookie with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ZookieMultiError, or nil if none found.
func (m *Zookie) ValidateAll() error {
	return m.validate(true)
}

func (m *Zookie) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetToken()) < 1 {
		err := ZookieValidationError{
			field:  "Token",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ZookieMultiError(errors)
	}

	return nil
}

// ZookieMultiError is an error wrapping multiple validation errors returned by
// Zookie.ValidateAll() if the designated constraints aren't met.
type ZookieMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZookieMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZookieMultiError) AllErrors() []error { return m }

// ZookieValidationError is the validation error returned by Zookie.Validate if
// the designated constraints aren't met.
type ZookieValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZookieValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZookieValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZookieValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZookieValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZookieValidationError) ErrorName() string { return "ZookieValidationError" }

// Error satisfies the builtin error interface
func (e ZookieValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZookie.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZookieValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZookieValidationError{}

// Validate checks the field values on RelationTupleUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RelationTupleUpdate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationTupleUpdate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationTupleUpdateMultiError, or nil if none found.
func (m *RelationTupleUpdate) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationTupleUpdate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := RelationTupleUpdate_Operation_name[int32(m.GetOperation())]; !ok {
		err := RelationTupleUpdateValidationError{
			field:  "Operation",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTuple() == nil {
		err := RelationTupleUpdateValidationError{
			field:  "Tuple",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTuple()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationTupleUpdateValidationError{
					field:  "Tuple",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationTupleUpdateValidationError{
					field:  "Tuple",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTuple()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationTupleUpdateValidationError{
				field:  "Tuple",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RelationTupleUpdateMultiError(errors)
	}

	return nil
}

// RelationTupleUpdateMultiError is an error wrapping multiple validation
// errors returned by RelationTupleUpdate.ValidateAll() if the designated
// constraints aren't met.
type RelationTupleUpdateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationTupleUpdateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationTupleUpdateMultiError) AllErrors() []error { return m }

// RelationTupleUpdateValidationError is the validation error returned by
// RelationTupleUpdate.Validate if the designated constraints aren't met.
type RelationTupleUpdateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationTupleUpdateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationTupleUpdateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationTupleUpdateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationTupleUpdateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationTupleUpdateValidationError) ErrorName() string {
	return "RelationTupleUpdateValidationError"
}

// Error satisfies the builtin error interface
func (e RelationTupleUpdateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationTupleUpdate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationTupleUpdateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationTupleUpdateValidationError{}

// Validate checks the field values on RelationTupleTreeNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RelationTupleTreeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RelationTupleTreeNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RelationTupleTreeNodeMultiError, or nil if none found.
func (m *RelationTupleTreeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *RelationTupleTreeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpanded()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationTupleTreeNodeValidationError{
					field:  "Expanded",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationTupleTreeNodeValidationError{
					field:  "Expanded",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpanded()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationTupleTreeNodeValidationError{
				field:  "Expanded",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.NodeType.(type) {

	case *RelationTupleTreeNode_IntermediateNode:

		if all {
			switch v := interface{}(m.GetIntermediateNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RelationTupleTreeNodeValidationError{
						field:  "IntermediateNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RelationTupleTreeNodeValidationError{
						field:  "IntermediateNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntermediateNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RelationTupleTreeNodeValidationError{
					field:  "IntermediateNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *RelationTupleTreeNode_LeafNode:

		if all {
			switch v := interface{}(m.GetLeafNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RelationTupleTreeNodeValidationError{
						field:  "LeafNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RelationTupleTreeNodeValidationError{
						field:  "LeafNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLeafNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RelationTupleTreeNodeValidationError{
					field:  "LeafNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RelationTupleTreeNodeMultiError(errors)
	}

	return nil
}

// RelationTupleTreeNodeMultiError is an error wrapping multiple validation
// errors returned by RelationTupleTreeNode.ValidateAll() if the designated
// constraints aren't met.
type RelationTupleTreeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationTupleTreeNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationTupleTreeNodeMultiError) AllErrors() []error { return m }

// RelationTupleTreeNodeValidationError is the validation error returned by
// RelationTupleTreeNode.Validate if the designated constraints aren't met.
type RelationTupleTreeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationTupleTreeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationTupleTreeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationTupleTreeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationTupleTreeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationTupleTreeNodeValidationError) ErrorName() string {
	return "RelationTupleTreeNodeValidationError"
}

// Error satisfies the builtin error interface
func (e RelationTupleTreeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelationTupleTreeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationTupleTreeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationTupleTreeNodeValidationError{}

// Validate checks the field values on SetOperationUserset with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetOperationUserset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOperationUserset with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetOperationUsersetMultiError, or nil if none found.
func (m *SetOperationUserset) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOperationUserset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Operation

	for idx, item := range m.GetChildNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperationUsersetValidationError{
						field:  fmt.Sprintf("ChildNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperationUsersetValidationError{
						field:  fmt.Sprintf("ChildNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperationUsersetValidationError{
					field:  fmt.Sprintf("ChildNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetOperationUsersetMultiError(errors)
	}

	return nil
}

// SetOperationUsersetMultiError is an error wrapping multiple validation
// errors returned by SetOperationUserset.ValidateAll() if the designated
// constraints aren't met.
type SetOperationUsersetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOperationUsersetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOperationUsersetMultiError) AllErrors() []error { return m }

// SetOperationUsersetValidationError is the validation error returned by
// SetOperationUserset.Validate if the designated constraints aren't met.
type SetOperationUsersetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOperationUsersetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOperationUsersetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOperationUsersetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOperationUsersetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOperationUsersetValidationError) ErrorName() string {
	return "SetOperationUsersetValidationError"
}

// Error satisfies the builtin error interface
func (e SetOperationUsersetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOperationUserset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOperationUsersetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOperationUsersetValidationError{}

// Validate checks the field values on DirectUserset with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DirectUserset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DirectUserset with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DirectUsersetMultiError, or
// nil if none found.
func (m *DirectUserset) ValidateAll() error {
	return m.validate(true)
}

func (m *DirectUserset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DirectUsersetValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DirectUsersetValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DirectUsersetValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DirectUsersetMultiError(errors)
	}

	return nil
}

// DirectUsersetMultiError is an error wrapping multiple validation errors
// returned by DirectUserset.ValidateAll() if the designated constraints
// aren't met.
type DirectUsersetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DirectUsersetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DirectUsersetMultiError) AllErrors() []error { return m }

// DirectUsersetValidationError is the validation error returned by
// DirectUserset.Validate if the designated constraints aren't met.
type DirectUsersetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DirectUsersetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DirectUsersetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DirectUsersetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DirectUsersetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DirectUsersetValidationError) ErrorName() string { return "DirectUsersetValidationError" }

// Error satisfies the builtin error interface
func (e DirectUsersetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDirectUserset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DirectUsersetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DirectUsersetValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetMetadataMessage()) < 1 {
		err := MetadataValidationError{
			field:  "MetadataMessage",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetMetadataMessage() {
		_, _ = idx, item

		if item == nil {
			err := MetadataValidationError{
				field:  fmt.Sprintf("MetadataMessage[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if a := item; a != nil {

			if _, ok := _Metadata_MetadataMessage_InLookup[a.GetTypeUrl()]; !ok {
				err := MetadataValidationError{
					field:  fmt.Sprintf("MetadataMessage[%v]", idx),
					reason: "type URL must be in list [type.googleapis.com/impl.v1.DocComment type.googleapis.com/impl.v1.RelationMetadata]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on NamespaceDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamespaceDefinition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceDefinition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamespaceDefinitionMultiError, or nil if none found.
func (m *NamespaceDefinition) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceDefinition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 128 {
		err := NamespaceDefinitionValidationError{
			field:  "Name",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_NamespaceDefinition_Name_Pattern.MatchString(m.GetName()) {
		err := NamespaceDefinitionValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,62}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRelation() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceDefinitionValidationError{
						field:  fmt.Sprintf("Relation[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceDefinitionValidationError{
						field:  fmt.Sprintf("Relation[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceDefinitionValidationError{
					field:  fmt.Sprintf("Relation[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceDefinitionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceDefinitionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceDefinitionValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamespaceDefinitionValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamespaceDefinitionValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamespaceDefinitionValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamespaceDefinitionMultiError(errors)
	}

	return nil
}

// NamespaceDefinitionMultiError is an error wrapping multiple validation
// errors returned by NamespaceDefinition.ValidateAll() if the designated
// constraints aren't met.
type NamespaceDefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceDefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceDefinitionMultiError) AllErrors() []error { return m }

// NamespaceDefinitionValidationError is the validation error returned by
// NamespaceDefinition.Validate if the designated constraints aren't met.
type NamespaceDefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceDefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceDefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceDefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceDefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceDefinitionValidationError) ErrorName() string {
	return "NamespaceDefinitionValidationError"
}

// Error satisfies the builtin error interface
func (e NamespaceDefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceDefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceDefinitionValidationError{}

var _NamespaceDefinition_Name_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,62}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$")

// Validate checks the field values on Relation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Relation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Relation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RelationMultiError, or nil
// if none found.
func (m *Relation) ValidateAll() error {
	return m.validate(true)
}

func (m *Relation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetName()) > 64 {
		err := RelationValidationError{
			field:  "Name",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Relation_Name_Pattern.MatchString(m.GetName()) {
		err := RelationValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetUsersetRewrite()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "UsersetRewrite",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "UsersetRewrite",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUsersetRewrite()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationValidationError{
				field:  "UsersetRewrite",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTypeInformation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "TypeInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "TypeInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTypeInformation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationValidationError{
				field:  "TypeInformation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RelationValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RelationValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AliasingRelation

	// no validation rules for CanonicalCacheKey

	if len(errors) > 0 {
		return RelationMultiError(errors)
	}

	return nil
}

// RelationMultiError is an error wrapping multiple validation errors returned
// by Relation.ValidateAll() if the designated constraints aren't met.
type RelationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RelationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RelationMultiError) AllErrors() []error { return m }

// RelationValidationError is the validation error returned by
// Relation.Validate if the designated constraints aren't met.
type RelationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RelationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RelationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RelationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RelationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RelationValidationError) ErrorName() string { return "RelationValidationError" }

// Error satisfies the builtin error interface
func (e RelationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRelation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RelationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RelationValidationError{}

var _Relation_Name_Pattern = regexp.MustCompile("^[a-z][a-z0-9_]{1,62}[a-z0-9]$")

// Validate checks the field values on TypeInformation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TypeInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TypeInformation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TypeInformationMultiError, or nil if none found.
func (m *TypeInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *TypeInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAllowedDirectRelations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeInformationValidationError{
						field:  fmt.Sprintf("AllowedDirectRelations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeInformationValidationError{
						field:  fmt.Sprintf("AllowedDirectRelations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeInformationValidationError{
					field:  fmt.Sprintf("AllowedDirectRelations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TypeInformationMultiError(errors)
	}

	return nil
}

// TypeInformationMultiError is an error wrapping multiple validation errors
// returned by TypeInformation.ValidateAll() if the designated constraints
// aren't met.
type TypeInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TypeInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TypeInformationMultiError) AllErrors() []error { return m }

// TypeInformationValidationError is the validation error returned by
// TypeInformation.Validate if the designated constraints aren't met.
type TypeInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TypeInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TypeInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TypeInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TypeInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TypeInformationValidationError) ErrorName() string { return "TypeInformationValidationError" }

// Error satisfies the builtin error interface
func (e TypeInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTypeInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TypeInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TypeInformationValidationError{}

// Validate checks the field values on AllowedRelation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AllowedRelation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllowedRelation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AllowedRelationMultiError, or nil if none found.
func (m *AllowedRelation) ValidateAll() error {
	return m.validate(true)
}

func (m *AllowedRelation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetNamespace()) > 128 {
		err := AllowedRelationValidationError{
			field:  "Namespace",
			reason: "value length must be at most 128 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_AllowedRelation_Namespace_Pattern.MatchString(m.GetNamespace()) {
		err := AllowedRelationValidationError{
			field:  "Namespace",
			reason: "value does not match regex pattern \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AllowedRelationValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AllowedRelationValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AllowedRelationValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.RelationOrWildcard.(type) {

	case *AllowedRelation_Relation:

		if len(m.GetRelation()) > 64 {
			err := AllowedRelationValidationError{
				field:  "Relation",
				reason: "value length must be at most 64 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if !_AllowedRelation_Relation_Pattern.MatchString(m.GetRelation()) {
			err := AllowedRelationValidationError{
				field:  "Relation",
				reason: "value does not match regex pattern \"^(\\\\.\\\\.\\\\.|[a-z][a-z0-9_]{1,62}[a-z0-9])$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *AllowedRelation_PublicWildcard_:

		if all {
			switch v := interface{}(m.GetPublicWildcard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AllowedRelationValidationError{
						field:  "PublicWildcard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AllowedRelationValidationError{
						field:  "PublicWildcard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPublicWildcard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AllowedRelationValidationError{
					field:  "PublicWildcard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AllowedRelationMultiError(errors)
	}

	return nil
}

// AllowedRelationMultiError is an error wrapping multiple validation errors
// returned by AllowedRelation.ValidateAll() if the designated constraints
// aren't met.
type AllowedRelationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllowedRelationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllowedRelationMultiError) AllErrors() []error { return m }

// AllowedRelationValidationError is the validation error returned by
// AllowedRelation.Validate if the designated constraints aren't met.
type AllowedRelationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllowedRelationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllowedRelationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllowedRelationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllowedRelationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllowedRelationValidationError) ErrorName() string { return "AllowedRelationValidationError" }

// Error satisfies the builtin error interface
func (e AllowedRelationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllowedRelation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllowedRelationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllowedRelationValidationError{}

var _AllowedRelation_Namespace_Pattern = regexp.MustCompile("^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$")

var _AllowedRelation_Relation_Pattern = regexp.MustCompile("^(\\.\\.\\.|[a-z][a-z0-9_]{1,62}[a-z0-9])$")

// Validate checks the field values on UsersetRewrite with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UsersetRewrite) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UsersetRewrite with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UsersetRewriteMultiError,
// or nil if none found.
func (m *UsersetRewrite) ValidateAll() error {
	return m.validate(true)
}

func (m *UsersetRewrite) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UsersetRewriteValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UsersetRewriteValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UsersetRewriteValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.RewriteOperation.(type) {

	case *UsersetRewrite_Union:

		if m.GetUnion() == nil {
			err := UsersetRewriteValidationError{
				field:  "Union",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUnion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UsersetRewriteValidationError{
						field:  "Union",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UsersetRewriteValidationError{
						field:  "Union",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsersetRewriteValidationError{
					field:  "Union",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UsersetRewrite_Intersection:

		if m.GetIntersection() == nil {
			err := UsersetRewriteValidationError{
				field:  "Intersection",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIntersection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UsersetRewriteValidationError{
						field:  "Intersection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UsersetRewriteValidationError{
						field:  "Intersection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntersection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsersetRewriteValidationError{
					field:  "Intersection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UsersetRewrite_Exclusion:

		if m.GetExclusion() == nil {
			err := UsersetRewriteValidationError{
				field:  "Exclusion",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExclusion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UsersetRewriteValidationError{
						field:  "Exclusion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UsersetRewriteValidationError{
						field:  "Exclusion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExclusion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UsersetRewriteValidationError{
					field:  "Exclusion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := UsersetRewriteValidationError{
			field:  "RewriteOperation",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return UsersetRewriteMultiError(errors)
	}

	return nil
}

// UsersetRewriteMultiError is an error wrapping multiple validation errors
// returned by UsersetRewrite.ValidateAll() if the designated constraints
// aren't met.
type UsersetRewriteMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UsersetRewriteMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UsersetRewriteMultiError) AllErrors() []error { return m }

// UsersetRewriteValidationError is the validation error returned by
// UsersetRewrite.Validate if the designated constraints aren't met.
type UsersetRewriteValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsersetRewriteValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsersetRewriteValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsersetRewriteValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsersetRewriteValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsersetRewriteValidationError) ErrorName() string { return "UsersetRewriteValidationError" }

// Error satisfies the builtin error interface
func (e UsersetRewriteValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsersetRewrite.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsersetRewriteValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsersetRewriteValidationError{}

// Validate checks the field values on SetOperation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetOperation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOperation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetOperationMultiError, or
// nil if none found.
func (m *SetOperation) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOperation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetChild()) < 1 {
		err := SetOperationValidationError{
			field:  "Child",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetChild() {
		_, _ = idx, item

		if item == nil {
			err := SetOperationValidationError{
				field:  fmt.Sprintf("Child[%v]", idx),
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperationValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperationValidationError{
						field:  fmt.Sprintf("Child[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperationValidationError{
					field:  fmt.Sprintf("Child[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetOperationMultiError(errors)
	}

	return nil
}

// SetOperationMultiError is an error wrapping multiple validation errors
// returned by SetOperation.ValidateAll() if the designated constraints aren't met.
type SetOperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOperationMultiError) AllErrors() []error { return m }

// SetOperationValidationError is the validation error returned by
// SetOperation.Validate if the designated constraints aren't met.
type SetOperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOperationValidationError) ErrorName() string { return "SetOperationValidationError" }

// Error satisfies the builtin error interface
func (e SetOperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOperationValidationError{}

// Validate checks the field values on TupleToUserset with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TupleToUserset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TupleToUserset with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TupleToUsersetMultiError,
// or nil if none found.
func (m *TupleToUserset) ValidateAll() error {
	return m.validate(true)
}

func (m *TupleToUserset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTupleset() == nil {
		err := TupleToUsersetValidationError{
			field:  "Tupleset",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTupleset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TupleToUsersetValidationError{
					field:  "Tupleset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TupleToUsersetValidationError{
					field:  "Tupleset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTupleset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TupleToUsersetValidationError{
				field:  "Tupleset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetComputedUserset() == nil {
		err := TupleToUsersetValidationError{
			field:  "ComputedUserset",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetComputedUserset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TupleToUsersetValidationError{
					field:  "ComputedUserset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TupleToUsersetValidationError{
					field:  "ComputedUserset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetComputedUserset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TupleToUsersetValidationError{
				field:  "ComputedUserset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TupleToUsersetValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TupleToUsersetValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TupleToUsersetValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TupleToUsersetMultiError(errors)
	}

	return nil
}

// TupleToUsersetMultiError is an error wrapping multiple validation errors
// returned by TupleToUserset.ValidateAll() if the designated constraints
// aren't met.
type TupleToUsersetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TupleToUsersetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TupleToUsersetMultiError) AllErrors() []error { return m }

// TupleToUsersetValidationError is the validation error returned by
// TupleToUserset.Validate if the designated constraints aren't met.
type TupleToUsersetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TupleToUsersetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TupleToUsersetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TupleToUsersetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TupleToUsersetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TupleToUsersetValidationError) ErrorName() string { return "TupleToUsersetValidationError" }

// Error satisfies the builtin error interface
func (e TupleToUsersetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTupleToUserset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TupleToUsersetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TupleToUsersetValidationError{}

// Validate checks the field values on ComputedUserset with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ComputedUserset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComputedUserset with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComputedUsersetMultiError, or nil if none found.
func (m *ComputedUserset) ValidateAll() error {
	return m.validate(true)
}

func (m *ComputedUserset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := ComputedUserset_Object_name[int32(m.GetObject())]; !ok {
		err := ComputedUsersetValidationError{
			field:  "Object",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetRelation()) > 64 {
		err := ComputedUsersetValidationError{
			field:  "Relation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ComputedUserset_Relation_Pattern.MatchString(m.GetRelation()) {
		err := ComputedUsersetValidationError{
			field:  "Relation",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ComputedUsersetValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ComputedUsersetValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ComputedUsersetValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ComputedUsersetMultiError(errors)
	}

	return nil
}

// ComputedUsersetMultiError is an error wrapping multiple validation errors
// returned by ComputedUserset.ValidateAll() if the designated constraints
// aren't met.
type ComputedUsersetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComputedUsersetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComputedUsersetMultiError) AllErrors() []error { return m }

// ComputedUsersetValidationError is the validation error returned by
// ComputedUserset.Validate if the designated constraints aren't met.
type ComputedUsersetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComputedUsersetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComputedUsersetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComputedUsersetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComputedUsersetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComputedUsersetValidationError) ErrorName() string { return "ComputedUsersetValidationError" }

// Error satisfies the builtin error interface
func (e ComputedUsersetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComputedUserset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComputedUsersetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComputedUsersetValidationError{}

var _ComputedUserset_Relation_Pattern = regexp.MustCompile("^[a-z][a-z0-9_]{1,62}[a-z0-9]$")

// Validate checks the field values on SourcePosition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SourcePosition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SourcePosition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SourcePositionMultiError,
// or nil if none found.
func (m *SourcePosition) ValidateAll() error {
	return m.validate(true)
}

func (m *SourcePosition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ZeroIndexedLineNumber

	// no validation rules for ZeroIndexedColumnPosition

	if len(errors) > 0 {
		return SourcePositionMultiError(errors)
	}

	return nil
}

// SourcePositionMultiError is an error wrapping multiple validation errors
// returned by SourcePosition.ValidateAll() if the designated constraints
// aren't met.
type SourcePositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourcePositionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourcePositionMultiError) AllErrors() []error { return m }

// SourcePositionValidationError is the validation error returned by
// SourcePosition.Validate if the designated constraints aren't met.
type SourcePositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourcePositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourcePositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourcePositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourcePositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourcePositionValidationError) ErrorName() string { return "SourcePositionValidationError" }

// Error satisfies the builtin error interface
func (e SourcePositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSourcePosition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourcePositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourcePositionValidationError{}

// Validate checks the field values on AllowedRelation_PublicWildcard with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AllowedRelation_PublicWildcard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllowedRelation_PublicWildcard with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AllowedRelation_PublicWildcardMultiError, or nil if none found.
func (m *AllowedRelation_PublicWildcard) ValidateAll() error {
	return m.validate(true)
}

func (m *AllowedRelation_PublicWildcard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AllowedRelation_PublicWildcardMultiError(errors)
	}

	return nil
}

// AllowedRelation_PublicWildcardMultiError is an error wrapping multiple
// validation errors returned by AllowedRelation_PublicWildcard.ValidateAll()
// if the designated constraints aren't met.
type AllowedRelation_PublicWildcardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllowedRelation_PublicWildcardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllowedRelation_PublicWildcardMultiError) AllErrors() []error { return m }

// AllowedRelation_PublicWildcardValidationError is the validation error
// returned by AllowedRelation_PublicWildcard.Validate if the designated
// constraints aren't met.
type AllowedRelation_PublicWildcardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllowedRelation_PublicWildcardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllowedRelation_PublicWildcardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllowedRelation_PublicWildcardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllowedRelation_PublicWildcardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllowedRelation_PublicWildcardValidationError) ErrorName() string {
	return "AllowedRelation_PublicWildcardValidationError"
}

// Error satisfies the builtin error interface
func (e AllowedRelation_PublicWildcardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllowedRelation_PublicWildcard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllowedRelation_PublicWildcardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllowedRelation_PublicWildcardValidationError{}

// Validate checks the field values on SetOperation_Child with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetOperation_Child) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOperation_Child with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetOperation_ChildMultiError, or nil if none found.
func (m *SetOperation_Child) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOperation_Child) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSourcePosition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetOperation_ChildValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetOperation_ChildValidationError{
					field:  "SourcePosition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourcePosition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetOperation_ChildValidationError{
				field:  "SourcePosition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.ChildType.(type) {

	case *SetOperation_Child_XThis:

		if all {
			switch v := interface{}(m.GetXThis()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "XThis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "XThis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetXThis()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperation_ChildValidationError{
					field:  "XThis",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SetOperation_Child_ComputedUserset:

		if m.GetComputedUserset() == nil {
			err := SetOperation_ChildValidationError{
				field:  "ComputedUserset",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetComputedUserset()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "ComputedUserset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "ComputedUserset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetComputedUserset()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperation_ChildValidationError{
					field:  "ComputedUserset",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SetOperation_Child_TupleToUserset:

		if m.GetTupleToUserset() == nil {
			err := SetOperation_ChildValidationError{
				field:  "TupleToUserset",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTupleToUserset()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "TupleToUserset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "TupleToUserset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTupleToUserset()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperation_ChildValidationError{
					field:  "TupleToUserset",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SetOperation_Child_UsersetRewrite:

		if m.GetUsersetRewrite() == nil {
			err := SetOperation_ChildValidationError{
				field:  "UsersetRewrite",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUsersetRewrite()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "UsersetRewrite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "UsersetRewrite",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUsersetRewrite()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperation_ChildValidationError{
					field:  "UsersetRewrite",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SetOperation_Child_XNil:

		if all {
			switch v := interface{}(m.GetXNil()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "XNil",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetOperation_ChildValidationError{
						field:  "XNil",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetXNil()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetOperation_ChildValidationError{
					field:  "XNil",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		err := SetOperation_ChildValidationError{
			field:  "ChildType",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)

	}

	if len(errors) > 0 {
		return SetOperation_ChildMultiError(errors)
	}

	return nil
}

// SetOperation_ChildMultiError is an error wrapping multiple validation errors
// returned by SetOperation_Child.ValidateAll() if the designated constraints
// aren't met.
type SetOperation_ChildMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOperation_ChildMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOperation_ChildMultiError) AllErrors() []error { return m }

// SetOperation_ChildValidationError is the validation error returned by
// SetOperation_Child.Validate if the designated constraints aren't met.
type SetOperation_ChildValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOperation_ChildValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOperation_ChildValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOperation_ChildValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOperation_ChildValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOperation_ChildValidationError) ErrorName() string {
	return "SetOperation_ChildValidationError"
}

// Error satisfies the builtin error interface
func (e SetOperation_ChildValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOperation_Child.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOperation_ChildValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOperation_ChildValidationError{}

// Validate checks the field values on SetOperation_Child_This with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetOperation_Child_This) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOperation_Child_This with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetOperation_Child_ThisMultiError, or nil if none found.
func (m *SetOperation_Child_This) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOperation_Child_This) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetOperation_Child_ThisMultiError(errors)
	}

	return nil
}

// SetOperation_Child_ThisMultiError is an error wrapping multiple validation
// errors returned by SetOperation_Child_This.ValidateAll() if the designated
// constraints aren't met.
type SetOperation_Child_ThisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOperation_Child_ThisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOperation_Child_ThisMultiError) AllErrors() []error { return m }

// SetOperation_Child_ThisValidationError is the validation error returned by
// SetOperation_Child_This.Validate if the designated constraints aren't met.
type SetOperation_Child_ThisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOperation_Child_ThisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOperation_Child_ThisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOperation_Child_ThisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOperation_Child_ThisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOperation_Child_ThisValidationError) ErrorName() string {
	return "SetOperation_Child_ThisValidationError"
}

// Error satisfies the builtin error interface
func (e SetOperation_Child_ThisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOperation_Child_This.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOperation_Child_ThisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOperation_Child_ThisValidationError{}

// Validate checks the field values on SetOperation_Child_Nil with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetOperation_Child_Nil) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOperation_Child_Nil with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetOperation_Child_NilMultiError, or nil if none found.
func (m *SetOperation_Child_Nil) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOperation_Child_Nil) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetOperation_Child_NilMultiError(errors)
	}

	return nil
}

// SetOperation_Child_NilMultiError is an error wrapping multiple validation
// errors returned by SetOperation_Child_Nil.ValidateAll() if the designated
// constraints aren't met.
type SetOperation_Child_NilMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOperation_Child_NilMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOperation_Child_NilMultiError) AllErrors() []error { return m }

// SetOperation_Child_NilValidationError is the validation error returned by
// SetOperation_Child_Nil.Validate if the designated constraints aren't met.
type SetOperation_Child_NilValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOperation_Child_NilValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOperation_Child_NilValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOperation_Child_NilValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOperation_Child_NilValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOperation_Child_NilValidationError) ErrorName() string {
	return "SetOperation_Child_NilValidationError"
}

// Error satisfies the builtin error interface
func (e SetOperation_Child_NilValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOperation_Child_Nil.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOperation_Child_NilValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOperation_Child_NilValidationError{}

// Validate checks the field values on TupleToUserset_Tupleset with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TupleToUserset_Tupleset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TupleToUserset_Tupleset with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TupleToUserset_TuplesetMultiError, or nil if none found.
func (m *TupleToUserset_Tupleset) ValidateAll() error {
	return m.validate(true)
}

func (m *TupleToUserset_Tupleset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetRelation()) > 64 {
		err := TupleToUserset_TuplesetValidationError{
			field:  "Relation",
			reason: "value length must be at most 64 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_TupleToUserset_Tupleset_Relation_Pattern.MatchString(m.GetRelation()) {
		err := TupleToUserset_TuplesetValidationError{
			field:  "Relation",
			reason: "value does not match regex pattern \"^[a-z][a-z0-9_]{1,62}[a-z0-9]$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TupleToUserset_TuplesetMultiError(errors)
	}

	return nil
}

// TupleToUserset_TuplesetMultiError is an error wrapping multiple validation
// errors returned by TupleToUserset_Tupleset.ValidateAll() if the designated
// constraints aren't met.
type TupleToUserset_TuplesetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TupleToUserset_TuplesetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TupleToUserset_TuplesetMultiError) AllErrors() []error { return m }

// TupleToUserset_TuplesetValidationError is the validation error returned by
// TupleToUserset_Tupleset.Validate if the designated constraints aren't met.
type TupleToUserset_TuplesetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TupleToUserset_TuplesetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TupleToUserset_TuplesetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TupleToUserset_TuplesetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TupleToUserset_TuplesetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TupleToUserset_TuplesetValidationError) ErrorName() string {
	return "TupleToUserset_TuplesetValidationError"
}

// Error satisfies the builtin error interface
func (e TupleToUserset_TuplesetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTupleToUserset_Tupleset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TupleToUserset_TuplesetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TupleToUserset_TuplesetValidationError{}

var _TupleToUserset_Tupleset_Relation_Pattern = regexp.MustCompile("^[a-z][a-z0-9_]{1,62}[a-z0-9]$")
